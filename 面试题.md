# java基础及源码

1. java泛型的好处

   确保编译期的类型安全，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。比如List<String>运行时就是 List

2. arrayList

   默认10，一次扩容1.5倍，ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。vector每次增长两倍

3. Transient 关键字

   被修饰的字段不会被序列化
   
4. synchronized与ReentrantLock比较

   1. 锁实现方式：synchronized是jvm实现；ReentrantLock是JDK实现
   2. 性能相差不多
   3. 等待可中断ReentrantLock可以，synchronized不行
   4. 公平锁：ReentrantLock默认非公平。synchronized非公平

5. 并发很多，如果控制每次并发只有限制数

   使用Semaphore信号量设置限制数

6. 异步转同步方法？多个线程等待等线程到达时执行的方法？

   CountDownLatch，CyclicBarrier

7. java内存模型的意义？

   Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。

8. 内存三大特性

   原子性、可见性、有序性

9. 什么是锁消除?

   锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。

   ```java
   public static String concatString(String s1, String s2, String s3) {
       StringBuffer sb = new StringBuffer();
       sb.append(s1);
       sb.append(s2);
       sb.append(s3);
       return sb.toString();
   }
   ```

   每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。

10. FileInputSteam与BufferInputSteam

    前者没有缓冲区会频繁切换两态，而后者由缓冲性能较好

# jvm

1. 运行时数据区域有哪些？

   程序计数器、本地方法栈，java虚拟机栈、队、方法区（运行时常量池）

2. 类的生命周期

   1. **加载（Loading）**

      加载是类加载的一个阶段，注意不要混淆。

      加载过程完成以下三件事：

      - 通过类的完全限定名称获取定义该类的二进制字节流。
      - 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
      - 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。

      其中二进制字节流可以从以下方式中获取：

      - 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
      - 从网络中获取，最典型的应用是 Applet。
      - 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
      - 由其他文件生成，例如由 JSP 文件生成对应的 Class 类

   2. **验证（Verification）**

      确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

   3. **准备（Preparation）**

      类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是**方法区的内存**。

      实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。

      初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。

      ```java
      public static int value = 123;
      ```

      如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。

      ```java
      public static final int value = 123;
      ```

   4. **解析（Resolution）**

      将常量池的符号引用替换为直接引用的过程。

      其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。

   5. **初始化（Initialization）**

   6. 使用（Using）

   7. 卸载（Unloading

3. 

# Redis

1. redis为什么是key，value的，为什么不是支持SQL的？

2. redis是多线程还是单线程？

   单线程指的是网络请求模块使用了一个线程，其他模块用了多个线程。

3. redis的持久化开启了RDB和AOF下重启服务是如何加载的？(10个人9个回答错误)

   混合持久，aof日志存放持久化开始到结束增量，重启先加载rdb在重放aof

4. redis如果做集群该如何规划？AKF/CAP如何实现和设计？

5. 10万用户一年365天的登录情况如何用redis存储，并快速检索任意时间窗内的活跃用户？

   使用位图，bitcount key 可以统计签到天数,使用bitpos key 0|1查看该数字从第几个开始即签到开始时间

6. redis的5种Value类型你用过几种，能举例吗？

7. 100万并发4G数据，10万并发400G数据，如何设计Redis存储方式？

8. redis cluster集群方案一共分为多少个槽。采用什么hash算法？

   16384个槽，采用CRC16然后对16384取模

# MQ



# 设计模式



# 多线程



# 高并发



# spring相关源码



1. 

# nio



# 算法



# 最终一致性